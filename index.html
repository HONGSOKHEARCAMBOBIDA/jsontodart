<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>JSON → Dart Model Converter</title>
  <style>
    :root{--bg:#0f1724;--card:#0b1220;--muted:#9aa4b2;--accent:#7c3aed}
    body{font-family:Inter,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial;background:linear-gradient(180deg,#071029 0%,#071733 100%);color:#e6eef6;margin:0;padding:24px}
    .wrap{max-width:980px;margin:0 auto;display:grid;grid-template-columns:1fr 1fr;gap:18px}
    header{grid-column:1/-1;margin-bottom:6px}
    h1{margin:0;font-size:20px}
    p.lead{margin:6px 0 18px;color:var(--muted)}
    .card{background:var(--card);padding:14px;border-radius:10px;box-shadow:0 6px 18px rgba(2,6,23,.6)}
    textarea{width:100%;height:300px;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,.04);background:transparent;color:inherit;font-family:monospace;font-size:13px}
    .controls{display:flex;gap:8px;align-items:center;margin-bottom:8px;flex-wrap:wrap}
    label{font-size:13px;color:var(--muted)}
    input[type=text]{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,.04);background:transparent;color:inherit}
    button{background:var(--accent);border:0;padding:8px 12px;border-radius:8px;color:white;cursor:pointer}
    pre{white-space:pre-wrap;font-family:monospace;font-size:13px;line-height:1.45}
    .footer{grid-column:1/-1;margin-top:12px;color:var(--muted);font-size:13px}
    .row{display:flex;gap:8px}
    .small{font-size:12px;color:var(--muted)}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>JSON → Dart Model Converter</h1>
      <p class="lead">Paste JSON on the left. Click "Generate" to produce Dart classes (null-safety, fromJson/toJson). You can copy or download the output.</p>
    </header>

    <section class="card">
      <div class="controls">
        <label class="small">Root class name:&nbsp;</label>
        <input id="rootName" type="text" value="AutoGenerated" />
        <label class="small"> &nbsp; | &nbsp; Options:</label>
        <label class="small"><input id="useNullSafety" type="checkbox" checked /> Null-safety</label>
        <button id="generateBtn">Generate</button>
        <button id="exampleBtn">Load example</button>
      </div>

      <textarea id="jsonInput" placeholder='Paste JSON here...'></textarea>
    </section>

    <section class="card">
      <div class="row" style="justify-content:space-between;align-items:center;margin-bottom:8px">
        <div class="small">Dart output</div>
        <div style="display:flex;gap:8px">
          <button id="copyBtn">Copy</button>
          <button id="downloadBtn">Download .dart</button>
        </div>
      </div>

      <pre id="dartOutput">// Generated Dart code will appear here</pre>
    </section>

    <div class="footer">Tip: Now supports wrapper objects (like {"data": [...]}) and generates nested models just like your example.<code>fromJson</code> and <code>toJson</code>. Complex edge-cases (heterogeneous arrays, union types) are handled as <code>dynamic</code>.</div>
  </div>

  <script>
    // --- Utilities ---
    function isInt(n){return Number.isInteger(n)}
    function isFloat(n){return typeof n === 'number' && !Number.isInteger(n)}

    // main generator
    document.getElementById('generateBtn').addEventListener('click', ()=>{
      const raw = document.getElementById('jsonInput').value.trim();
      const rootName = sanitizeClassName(document.getElementById('rootName').value || 'AutoGenerated');
      const nullSafe = document.getElementById('useNullSafety').checked;
      if(!raw){alert('Paste some JSON first');return}
      let data;
      try{data = JSON.parse(raw)}catch(e){alert('Invalid JSON: '+e.message);return}
      const generator = new DartGenerator(rootName, nullSafe);
      const code = generator.generate(data);
      document.getElementById('dartOutput').textContent = code;
    });

    document.getElementById('copyBtn').addEventListener('click', ()=>{
      navigator.clipboard.writeText(document.getElementById('dartOutput').textContent).then(()=>{
        alert('Copied to clipboard')
      }, ()=>alert('Copy failed'))
    });

    document.getElementById('downloadBtn').addEventListener('click', ()=>{
      const text = document.getElementById('dartOutput').textContent;
      const blob = new Blob([text], {type: 'text/plain'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = (document.getElementById('rootName').value || 'model') + '.dart';
      document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
    });

    document.getElementById('exampleBtn').addEventListener('click', ()=>{
      const ex = JSON.stringify({
        id:123,
        name:"Alice",
        price:12.5,
        tags:["sale","popular"],
        owner:{id:7,fullname:'Owner Name',active:true},
        reviews:[{user:'Bob',score:5},{user:'Cara',score:4}]
      },null,2);
      document.getElementById('jsonInput').value = ex;
    });

    function sanitizeClassName(s){
      return s.replace(/[^A-Za-z0-9_]/g,'').replace(/^\d+/,'') || 'AutoGenerated';
    }

    // DartGenerator class
    class DartGenerator{
      constructor(rootName, nullSafe){
        this.rootName = rootName;
        this.nullSafe = nullSafe;
        this.classes = new Map(); // name -> {fields,fromJson,toJson}
      }

      generate(data){
        this.classes.clear();
        const rootType = this.inferTypeAndCollect(this.rootName, data);
        // create header
        let out = '// GENERATED CODE - JSON → Dart\n// root: '+this.rootName+'\n\nimport ' + "'dart:convert'" + ";\n\n";
        // for each class in insertion order
        for(const [name,def] of this.classes){
          out += this.renderClass(name, def.fields) + '\n\n';
        }
        // if root is plain List/primitive, add helper
        if(rootType.startsWith('List<') || ['int','double','String','bool','dynamic'].includes(rootType)){
          out += '// root type: '+rootType+'\n';
        }
        return out.trim();
      }

      inferTypeAndCollect(preferredName, value){
        if(value === null) return 'dynamic';
        if(Array.isArray(value)){
          // infer array subtype
          if(value.length===0) return 'List<dynamic>';
          // find unified type
          const types = new Set();
          for(const el of value){ types.add(this.inferTypeAndCollect(preferredName + 'Item', el)); }
          if(types.size===1) return 'List<'+[...types][0]+'>';
          // multiple types -> dynamic
          return 'List<dynamic>';
        }
        const t = typeof value;
        if(t === 'number'){
          if(isInt(value)) return 'int';
          if(isFloat(value)) return 'double';
          return 'num';
        }
        if(t === 'boolean') return 'bool';
        if(t === 'string') return 'String';
        if(t === 'object'){
          // object -> class
          const className = sanitizeClassName(capitalize(preferredName));
          if(!this.classes.has(className)){
            const fields = {};
            for(const k of Object.keys(value)){
              const fieldVal = value[k];
              const safeFieldName = safeDartFieldName(k);
              const inferred = this.inferTypeAndCollect(capitalize(k), fieldVal);
              fields[safeFieldName] = { key:k, type: inferred };
            }
            this.classes.set(className, { fields });
          } else {
            // If class exists, we could merge fields — simple approach: add missing fields
            const existing = this.classes.get(className);
            for(const k of Object.keys(value)){
              const safeFieldName = safeDartFieldName(k);
              if(!existing.fields[safeFieldName]){
                existing.fields[safeFieldName] = { key:k, type: this.inferTypeAndCollect(capitalize(k), value[k]) };
              }
            }
          }
          return className;
        }
        return 'dynamic';
      }

      renderClass(name, fields){
        // fields: {fieldName: {key, type}}
        const lines = [];
        lines.push('class '+name+' {');
        // properties
        for(const [f,meta] of Object.entries(fields)){
          const t = meta.type + (this.nullSafe && !meta.type.endsWith('?') ? (meta.type.startsWith('List<') || meta.type==='dynamic' ? '' : '?') : '');
          lines.push('  final '+t+' '+f+';');
        }
        lines.push('');
        // constructor
        const ctorArgs = Object.keys(fields).map(f=> 'this.'+f).join(', ');
        lines.push('  '+name+'({'+ctorArgs+'});');
        lines.push('');
        // fromJson
        lines.push('  factory '+name+'.fromJson(Map<String, dynamic> json) {');
        lines.push('    return '+name+'(');
        for(const [f,meta] of Object.entries(fields)){
          const originalKey = meta.key;
          const type = meta.type;
          const parseExpr = this.deserializeExpression(type, 'json["'+escapeString(originalKey)+'"]');
          lines.push('      '+f+': '+parseExpr+',' );
        }
        lines.push('    );');
        lines.push('  }');
        lines.push('');
        // toJson
        lines.push('  Map<String, dynamic> toJson() {');
        lines.push('    return {');
        for(const [f,meta] of Object.entries(fields)){
          const originalKey = meta.key;
          const type = meta.type;
          const serExpr = this.serializeExpression(type, f);
          lines.push('      "'+escapeString(originalKey)+'": '+serExpr+',' );
        }
        lines.push('    };');
        lines.push('  }');
        lines.push('}');
        return lines.join('\n');
      }

      deserializeExpression(type, src){
        // basic types or List<T> or custom classes
        if(type==='int' || type==='double' || type==='num' || type==='String' || type==='bool' || type==='dynamic'){
          return src + ' as '+ (type==='dynamic' ? 'dynamic' : type);
        }
        const listMatch = type.match(/^List<(.+)>$/);
        if(listMatch){
          const inner = listMatch[1];
          if(['int','double','String','bool','dynamic','num'].includes(inner)){
            return '(json[\"\"] is List) ? (('+src+') as List).map((e) => e as '+inner+').toList() : null'.replace('(json[\"\"]', src);
          } else {
            // list of objects
            return '(('+src+') as List?)?.map((e) => '+inner+'.fromJson(e as Map<String,dynamic>)).toList()';
          }
        }
        // custom class
        return src + ' != null ? '+type+'.fromJson('+src + ' as Map<String,dynamic>) : null';
      }

      serializeExpression(type, varName){
        if(type==='int' || type==='double' || type==='num' || type==='String' || type==='bool' || type==='dynamic'){
          return varName;
        }
        const listMatch = type.match(/^List<(.+)>$/);
        if(listMatch){
          const inner = listMatch[1];
          if(['int','double','String','bool','dynamic','num'].includes(inner)){
            return varName;
          } else {
            return varName + '?.map((e) => e.toJson()).toList()';
          }
        }
        return varName + '?.toJson()';
      }
    }

    // helper functions
    function capitalize(s){return s.charAt(0).toUpperCase()+s.slice(1)}
    function safeDartFieldName(k){
      // convert illegal chars to underscore, and if starts with number prefix _
      let s = k.replace(/[^A-Za-z0-9_]/g,'_');
      if(/^\d/.test(s)) s = '_'+s;
      // if reserved word - append _
      const reserved = new Set(['class','void','int','double','bool','String','dynamic','for','while','if','else','new','return']);
      if(reserved.has(s)) s = s + '_';
      return s;
    }
    function escapeString(s){ return s.replace(/\\/g,'\\\\').replace(/\"/g,'\\\"') }

  </script>
</body>
</html>

